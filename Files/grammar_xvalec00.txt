LL gramatika

1)	<PROGRAM>		->	<FUNC_N>
2)	<FUNC_N>		->	<FUNC> <FUNC_N>
3)	<FUNC_N>		->	E

4)	<VAR_DEF>		->	<TYPE> id <INIT>;
5)	<VAR_DEF>		->	auto id <INIT>;
6)	<INIT>			-> 	= <EXPR>
7)	<INIT>			->	E
8)	<TYPE>			->	int
9)	<TYPE>			->	double
10)	<TYPE>			-> 	string

11)	<FUNC>			-> 	<TYPE> id <PAR_DEF_LIST> <DEC_OR_DEF>
12)	<DEC_OR_DEF>		->	<COMM_SEQ>
13)	<DEC_OR_DEF>		->	;
14)	<PAR_DEF_LIST>		->	( <PARAMS> )
15)	<PARAMS>		-> 	<TYPE> id <PARAMS_N>
16)	<PARAMS>		-> 	E
17)	<PARAMS_N>		-> 	, <TYPE> id <PARAMS_N>
18)	<PARAMS_N>		-> 	E

19)	<FUNC_CALL>		->	id = id( <TERMS> );
20)	<TERMS>			-> 	id <TERMS_N>
21)	<TERMS>			-> 	E
22)	<TERMS_N>		-> 	, id <TERMS_N>
23)	<TERMS_N>		-> 	E

24)	<COMM_SEQ>		-> 	{ <STMT_LIST> }
25)	<STMT_LIST>		->	<STMT> <STMT_LIST>
26)	<STMT_LIST>		->	E
27)	<STMT>			->	id = <FCALL_OR_ASSIGN>
28)	<STMT>			->	if <EXPR> <COMM_SEQ> <IF_N>
29)	<STMT>			->	for( <VAR_DEF> <EXPR> <ASSIGN> ) <COMM_SEQ>
30)	<STMT>			->	{ <COMM_SEQ> }
31)	<STMT>			->	<VAR_DEF>
32)	<STMT>			->	cin >> id <CIN_ID_N>;
33)	<STMT>			->	cout << <COUT_TERM>;
34)	<STMT>			->	<RETURN>
35)	<ASSIGN>		->	id = <EXPR> 
36)	<FCALL_OR_ASSIGN>	->	<EXPR> ;
37)	<FCALL_OR_ASSIGN>	->	id ( <TERMS> );

38)	<CIN_ID_N>		-> 	>> id <CIN_ID_N>
39)	<CIN_ID_N>		-> 	E
40)	<COUT_TERM>		-> 	id <COUT_TERM_N>
41)	<COUT_TERM_N>		-> 	<< <COUT_TERM_N>
42)	<COUT_TERM_N>		-> 	E

43)	<RETURN>		->	return <EXPR>;
44)	<IF_N>			->	else <COMM_SEQ>
45)	<IF_N>			->	E
â€ƒ

Gramatika pro vyrazy

<EXPR>		->	( <EXPR> )
<EXPR>		->	term
<EXPR>		->	id
<EXPR>		->	id( )
<EXPR>		->	id( arg <ARG_N> )
<ARG_N>		->	, arg <ARG_N>
<ARG_N>		->	E
<EXPR>		->	<EXPR> + <EXPR>
<EXPR>		->	<EXPR> - <EXPR>
<EXPR>		->	<EXPR> * <EXPR>
<EXPR>		->	<EXPR> / <EXPR>
<EXPR>		->	<EXPR> < <EXPR>
<EXPR>		->	<EXPR> > <EXPR>
<EXPR>		->	<EXPR> <= <EXPR>
<EXPR>		->	<EXPR> >= <EXPR>
<EXPR>		->	<EXPR> == <EXPR>
<EXPR>		->	<EXPR> != <EXPR>

